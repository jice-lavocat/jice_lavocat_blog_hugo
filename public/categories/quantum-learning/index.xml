<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Quantum Learning on World Hacks</title>
    <link>http://jice.lavocat.name/blog/categories/quantum-learning/</link>
    <description>Recent content in Quantum Learning on World Hacks</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All rights reserved - 2015</copyright>
    <lastBuildDate>Wed, 16 Sep 2009 00:00:00 +0000</lastBuildDate>
    <atom:link href="http://jice.lavocat.name/blog/categories/quantum-learning/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Impatient Learning and sub/sup Majority Problem</title>
      <link>http://jice.lavocat.name/blog/2009/09/impatient-learning-and-subsup-majority-problem/</link>
      <pubDate>Wed, 16 Sep 2009 00:00:00 +0000</pubDate>
      
      <guid>http://jice.lavocat.name/blog/2009/09/impatient-learning-and-subsup-majority-problem/</guid>
      <description>&lt;p style=&#34;text-align: justify;&#34;&gt;
  In this article I present some probabilities of 1-step learning optimized by Impatient Learning (&lt;a href=&#34;http://www.citebase.org/abstract?id=oai:arXiv.org:quant-ph/0309059&#34; target=&#34;_blank&#34;&gt;http://www.citebase.org/abstract?id=oai:arXiv.org:quant-ph/0309059&lt;/a&gt;) for the sub/sup Majority Learning.
&lt;/p&gt;

&lt;h2 style=&#34;text-align: justify;&#34;&gt;
  The (Sub/Sup) Majority Learning
&lt;/h2&gt;

&lt;p style=&#34;text-align: justify;&#34;&gt;
  Take a bitstring &lt;em&gt;a&lt;/em&gt;, and an integer $$\theta$$. The oracle will respond 0 if $$d(a,x)\leq \theta$$  if queried with &lt;em&gt;x&lt;/em&gt; and 1 otherwise. In other terms this oracle reply yes if two bitstrings agree on at least $$\theta$$ bit.
&lt;/p&gt;

&lt;p style=&#34;text-align: justify;&#34;&gt;
  Here are the probability with a simple membership oracle (used with the usual phase kickback trick). Only even &lt;em&gt;n&lt;/em&gt; gives an invertible matrix for the use of impatient learning.
&lt;/p&gt;

&lt;table style=&#34;width: 100%;&#34; border=&#34;0&#34; align=&#34;center&#34;&gt;
  &lt;tr style=&#34;text-align: center;&#34;&gt;
    &lt;td&gt;
      n \ theta
    &lt;/td&gt;
    
    &lt;td&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      1
    &lt;/td&gt;
    
    &lt;td&gt;
      2
    &lt;/td&gt;
    
    &lt;td&gt;
      3
    &lt;/td&gt;
    
    &lt;td&gt;
      4
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr style=&#34;text-align: center;&#34;&gt;
    &lt;td&gt;
      2
    &lt;/td&gt;
    
    &lt;td style=&#34;text-align: center;&#34;&gt;
      1
    &lt;/td&gt;
    
    &lt;td style=&#34;text-align: center;&#34;&gt;
      &lt;strong&gt;1&lt;/strong&gt;
    &lt;/td&gt;
    
    &lt;td style=&#34;text-align: center;&#34;&gt;
      X
    &lt;/td&gt;
    
    &lt;td&gt;
      X
    &lt;/td&gt;
    
    &lt;td&gt;
      X
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr style=&#34;text-align: center;&#34;&gt;
    &lt;td style=&#34;text-align: center;&#34;&gt;
      4
    &lt;/td&gt;
    
    &lt;td style=&#34;text-align: center;&#34;&gt;
      0.6875
    &lt;/td&gt;
    
    &lt;td&gt;
      0.875
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;strong&gt;0.875&lt;/strong&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      0.6875
    &lt;/td&gt;
    
    &lt;td&gt;
      X
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr style=&#34;text-align: center;&#34;&gt;
    &lt;td&gt;
      6
    &lt;/td&gt;
    
    &lt;td&gt;
      0.3671875
    &lt;/td&gt;
    
    &lt;td&gt;
      0.6171875
    &lt;/td&gt;
    
    &lt;td&gt;
      0.75
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;strong&gt;0.75&lt;/strong&gt;
    &lt;/td&gt;
    
    &lt;td&gt;
      0.6171875
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr style=&#34;text-align: center;&#34;&gt;
    &lt;td&gt;
      8
    &lt;/td&gt;
    
    &lt;td&gt;
      0.1865234
    &lt;/td&gt;
    
    &lt;td&gt;
      0.36132812
    &lt;/td&gt;
    
    &lt;td&gt;
      0.520508
    &lt;/td&gt;
    
    &lt;td&gt;
      0.6484
    &lt;/td&gt;
    
    &lt;td&gt;
      &lt;strong&gt;0.6484&lt;/strong&gt;
    &lt;/td&gt;
  &lt;/tr&gt;
  
  &lt;tr style=&#34;text-align: center;&#34;&gt;
    &lt;td&gt;
      10
    &lt;/td&gt;
    
    &lt;td&gt;
      0.0936279
    &lt;/td&gt;
    
    &lt;td&gt;
      0.1990967
    &lt;/td&gt;
    
    &lt;td&gt;
      0.312499
    &lt;/td&gt;
    
    &lt;td&gt;
      0.448241
    &lt;/td&gt;
    
    &lt;td&gt;
      0.5703125
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;

&lt;p style=&#34;text-align: justify;&#34;&gt;
  &lt;p style=&#34;text-align: justify;&#34;&gt;
    &lt;p style=&#34;text-align: justify;&#34;&gt;
      For all these value, the optimum is achieved when the phase kickback takes value in {-1 ; 1}.
    &lt;/p&gt;
    

&lt;pre&gt;&lt;code&gt;&amp;lt;p&amp;gt;
  &amp;lt;br class=&amp;quot;_mce_marker&amp;quot; /&amp;gt;
&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Classical algorithm for the Majority Problem</title>
      <link>http://jice.lavocat.name/blog/2009/07/classical-algorithm-for-the-majority-problem/</link>
      <pubDate>Tue, 07 Jul 2009 00:00:00 +0000</pubDate>
      
      <guid>http://jice.lavocat.name/blog/2009/07/classical-algorithm-for-the-majority-problem/</guid>
      <description>

&lt;h2 id=&#34;presentation-of-the-problem:3b8d5a267fec0b72a8c954f33097fb33&#34;&gt;Presentation of the problem :&lt;/h2&gt;

&lt;p style=&#34;text-align: justify;&#34;&gt;
  The majority problem is equivalent to the perceptron learning. For each $$a \in \mathbb{Z}_n$$ define a function $$m_a : \mathbb{Z}_2^N \rightarrow \mathbb{Z}_2$$ :
&lt;/p&gt;

&lt;p style=&#34;text-align: center;&#34;&gt;
  $$m_a(x)= \begin{cases} 1 &amp; \text{ if } wt(a-x)\leq n/2 \\0 &amp; \text{ otherwise } \end{cases}$$
&lt;/p&gt;

&lt;p style=&#34;text-align: justify;&#34;&gt;
  Where wt is the weight of a bit-string (number of 1).
&lt;/p&gt;

&lt;p style=&#34;text-align: justify;&#34;&gt;
  Alternatively we can write : $$ m_a(x) = \Theta (n/2 &amp;#8211; wt(x-a) )$$.
&lt;/p&gt;

&lt;p style=&#34;text-align: justify;&#34;&gt;
  The problem is : &lt;strong&gt;determine a&lt;/strong&gt; given an access to answers from $$m_a$$.
&lt;/p&gt;

&lt;p style=&#34;text-align: justify;&#34;&gt;
  We saw in the presentation (link available soon) that the classical complexity was $$ O(n)$$ while the quantum complexity was $$ O(\sqrt{n})$$. In the following we show the classical bound.
&lt;/p&gt;

&lt;p style=&#34;text-align: justify;&#34;&gt;
  &lt;h2 style=&#34;text-align: justify;&#34;&gt;
    The classical algorithm
  &lt;/h2&gt;
  
  &lt;p&gt;
    For the classical case we will use a dichotomic process as in the &lt;a href=&#34;http://en.wikipedia.org/wiki/Binary_search_algorithm&#34; target=&#34;_blank&#34;&gt;binary chop&lt;/a&gt;. Here is the algorithm :
  &lt;/p&gt;
  

&lt;p&gt;&lt;ul&gt;
    &lt;li&gt;
      At the first step you look the result for 0&amp;#8230;0. If it&amp;#8217;s 1 you take all the possible weights that could have the same result ($$2^n / 2 = 2^{n-1}$$ weights possible). If it&amp;#8217;s 0 you take the complementary set of bits (the same number of weights if n is even).
    &lt;/li&gt;
    &lt;li&gt;
      After that, you choose a new vector in your possible set, with the biggest Hamming distance with the previous tested bit. Then you look the result. After that step you would be able to remove another time : $$ 2^{n-1} / 2$$ remaining weights .
    &lt;/li&gt;
    &lt;li&gt;
      &amp;#8230; you repeat these steps n-1 times at all, in the end you have $$2^n/2^{n-1} = 2$$ possible states.
    &lt;/li&gt;
    &lt;li&gt;
      In the end, you may have two bits that you will separate by choosing a special bit &lt;strong&gt;b&lt;/strong&gt;.  This bit &lt;strong&gt;b&lt;/strong&gt; will depend on the two possible states and differentiate them.
    &lt;/li&gt;
    &lt;li&gt;
      And you are done in n steps.
    &lt;/li&gt;
  &lt;/ul&gt;&lt;/p&gt;

&lt;p&gt;&lt;h2&gt;
    Example for n=3
  &lt;/h2&gt;&lt;/p&gt;

&lt;p&gt;&lt;p&gt;
    For n=3, let&amp;#8217;s take the example of the following target bit : w = 001.
  &lt;/p&gt;&lt;/p&gt;

&lt;p&gt;&lt;ul&gt;
    &lt;li&gt;
      I first try 000. I get 1. So the possible weights are : 000 / 001 / 010 / 100
    &lt;/li&gt;
    &lt;li&gt;
      Then I test 001. I get 1. So the remaining states are 001 / 000 ( 011 / 101 are not possible because they are not in the previous set)
    &lt;/li&gt;
    &lt;li&gt;
      Finally I test 101. I get 1. &lt;em&gt;So the only possible result is 001&lt;/em&gt;.
    &lt;/li&gt;
  &lt;/ul&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Some papers about Oracle identification</title>
      <link>http://jice.lavocat.name/blog/2009/07/some-papers-about-oracle-identification/</link>
      <pubDate>Wed, 01 Jul 2009 00:00:00 +0000</pubDate>
      
      <guid>http://jice.lavocat.name/blog/2009/07/some-papers-about-oracle-identification/</guid>
      <description>&lt;p&gt;There is a bunch of interesting papers dealing with Oracle Identification.&lt;/p&gt;

&lt;p&gt;Here is a list of the ones I found interesting to read :&lt;/p&gt;

&lt;p&gt;First a general definition of the context : &lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://www.springerlink.com/content/8683h22113570t44/&#34; target=&#34;_blank&#34;&gt;Jorge Castro &amp;#8211;  How Many Query Superpositions Are Needed to Learn?&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A  paper about lots of bounds : &lt;a href=&#34;http://radiata.cs.columbia.edu/%7Erocco/Public/SG_041291_2.pdf&#34;&gt;Rocco Servedio &amp;amp; Steven Gortler &amp;#8211; Equivalences and separations between quantum and classical learnability&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Chapter 6 of &lt;a href=&#34;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.125.8675&amp;rep=rep1&amp;type=pdf&#34; target=&#34;_blank&#34;&gt;Ashley Montanaro &amp;#8211; Structure randomness &amp;#8230;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;A recent paper that tries to avoid quantum oracle queries : &lt;a href=&#34;http://www.springerlink.com/content/k6u13303p6725167/&#34; target=&#34;_blank&#34;&gt;Alp Atici &amp;amp; Rocco Servedio &amp;#8211; Quantum algorithms for learning and testing juntas&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;And finally a well-known chapter about technics for computing quantum complexities : &lt;a href=&#34;http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.32.6914&amp;rep=rep1&amp;type=pdf&#34; target=&#34;_blank&#34;&gt;&lt;span&gt;&lt;span&gt;Ethan Bernstein, Umesh Vazirani &amp;#8211; &lt;/span&gt;&lt;/span&gt;Quantum complexity theory&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Latex on my blog</title>
      <link>http://jice.lavocat.name/blog/2009/06/test-latex/</link>
      <pubDate>Fri, 19 Jun 2009 00:00:00 +0000</pubDate>
      
      <guid>http://jice.lavocat.name/blog/2009/06/test-latex/</guid>
      <description>&lt;p style=&#34;text-align: justify;&#34;&gt;
  WordPress permet d&amp;#8217;inclure du Latex dans ses pages grace a un script hébergé sur ses propres serveur. Voila qui va me rendre heureux tout ca :
&lt;/p&gt;

&lt;p style=&#34;text-align: center;&#34;&gt;
  
&lt;/p&gt;

&lt;p style=&#34;text-align: center;&#34;&gt;
  $$ i\hbar\frac{\partial}{\partial t}\left|\Psi(t)\right&gt;=H\left|\Psi(t)\right&gt;$$
&lt;/p&gt;

&lt;p style=&#34;text-align: justify;&#34;&gt;
  Vous pouvez aussi normalement écrire vos formules dans les commentaires en utilisant la syntaxe
&lt;/p&gt;

&lt;p&gt;`&lt;p style=&#34;text-align: justify;&#34;&gt;
  WordPress permet d&amp;#8217;inclure du Latex dans ses pages grace a un script hébergé sur ses propres serveur. Voila qui va me rendre heureux tout ca :
&lt;/p&gt;&lt;/p&gt;

&lt;p style=&#34;text-align: center;&#34;&gt;
  
&lt;/p&gt;

&lt;p style=&#34;text-align: center;&#34;&gt;
  $$ i\hbar\frac{\partial}{\partial t}\left|\Psi(t)\right&gt;=H\left|\Psi(t)\right&gt;$$
&lt;/p&gt;

&lt;p style=&#34;text-align: justify;&#34;&gt;
  Vous pouvez aussi normalement écrire vos formules dans les commentaires en utilisant la syntaxe
&lt;/p&gt;

&lt;p&gt;`&lt;/p&gt;

&lt;p&gt;Vous pouvez essayer ci-dessous, dans la mesure du raisonnable.&lt;/p&gt;

&lt;p&gt;_&lt;em&gt;__&lt;/em&gt;_&lt;em&gt;__&lt;/em&gt;______&lt;/p&gt;

&lt;p&gt;English version :&lt;/p&gt;

&lt;p&gt;You can now add Latex equations on my blog/comments. The correct syntax is&lt;/p&gt;

&lt;p&gt;``&lt;p style=&#34;text-align: justify;&#34;&gt;
  WordPress permet d&amp;#8217;inclure du Latex dans ses pages grace a un script hébergé sur ses propres serveur. Voila qui va me rendre heureux tout ca :
&lt;/p&gt;&lt;/p&gt;

&lt;p style=&#34;text-align: center;&#34;&gt;
  
&lt;/p&gt;

&lt;p style=&#34;text-align: center;&#34;&gt;
  $$ i\hbar\frac{\partial}{\partial t}\left|\Psi(t)\right&gt;=H\left|\Psi(t)\right&gt;$$
&lt;/p&gt;

&lt;p style=&#34;text-align: justify;&#34;&gt;
  Vous pouvez aussi normalement écrire vos formules dans les commentaires en utilisant la syntaxe
&lt;/p&gt;

&lt;p&gt;`&lt;p style=&#34;text-align: justify;&#34;&gt;
  WordPress permet d&amp;#8217;inclure du Latex dans ses pages grace a un script hébergé sur ses propres serveur. Voila qui va me rendre heureux tout ca :
&lt;/p&gt;&lt;/p&gt;

&lt;p style=&#34;text-align: center;&#34;&gt;
  
&lt;/p&gt;

&lt;p style=&#34;text-align: center;&#34;&gt;
  $$ i\hbar\frac{\partial}{\partial t}\left|\Psi(t)\right&gt;=H\left|\Psi(t)\right&gt;$$
&lt;/p&gt;

&lt;p style=&#34;text-align: justify;&#34;&gt;
  Vous pouvez aussi normalement écrire vos formules dans les commentaires en utilisant la syntaxe
&lt;/p&gt;

&lt;p&gt;`&lt;/p&gt;

&lt;p&gt;Vous pouvez essayer ci-dessous, dans la mesure du raisonnable.&lt;/p&gt;

&lt;p&gt;_&lt;em&gt;__&lt;/em&gt;_&lt;em&gt;__&lt;/em&gt;______&lt;/p&gt;

&lt;p&gt;English version :&lt;/p&gt;

&lt;p&gt;You can now add Latex equations on my blog/comments. The correct syntax is&lt;/p&gt;

&lt;p&gt;``&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>